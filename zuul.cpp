//latest save 22 November 2024, used an online C++ compiler which is why formatting is weird
//link to online version here: https://onlinegdb.com/qGhq6blrX
#include <iostream>
#include <cstring>
#include <map>
#include "room.h"
#include "item.h"

using namespace std;

void RECIPE(vector<const char*> vect, vector<item*> inv, room* myStore, char* recipe);
void INFO(char* name, char* recipe);
void GO(room* &currentRoom, int &moves);
void GET(room* &currentRoom, vector<item*> &inv);
void DROP(room* &currentRoom, vector<item*> &inv);
bool BAKE(room* myStore, vector<const char*> recipe, char* recipeName);

int main() {
	//all "rooms"
	room* HOME = new room("HOME", "1st St");
	room* R1 = new room("Road", "5th St");
	room* R2 = new room("Road", "2nd & 4th St");
	room* R3 = new room("Road", "2nd and 5th St");
	room* R4 = new room("Road", "2nd and 6th St");
	room* R5 = new room("Road", "3rd and 4th St");
	room* R6 = new room("Road", "3rd and 6th St");
	room* R7 = new room("Road", "3rd and 7th St");
	room* S1 = new room("DRY BASICS", "2nd St");
	room* S2 = new room("NUTS", "7th St");
	room* S3 = new room("EGGS", "3rd St");
	room* S4 = new room("FRUITS", "3rd St");
	room* S5 = new room("MY STORE", "3rd St");
	room* S6 = new room("DAIRY", "4th St");
	room* S7 = new room("SPICES", "6th St");
	room* S8 = new room("VEGGIES", "7th St");

	//all exits
	HOME->setExit('w', R1, HOME->exits);
	R1->setExit('n', R3, R1->exits);
	R1->setExit('e', HOME, R1->exits);
	R2->setExit('n', R5, R2->exits);
	R2->setExit('e', R3, R2->exits);
	R2->setExit('w', S1, R2->exits);
	R3->setExit('e', R4, R3->exits);
	R3->setExit('w', R2, R3->exits);
	R4->setExit('n', R6, R4->exits);
	R4->setExit('w', R3, R4->exits);
	R5->setExit('n', S6, R5->exits);
	R5->setExit('e', S4, R5->exits);
	R5->setExit('s', R2, R5->exits);
	R5->setExit('w', S3, R5->exits);
	R6->setExit('n', S7, R6->exits);
	R6->setExit('e', R7, R6->exits);
	R6->setExit('s', R4, R6->exits);
	R6->setExit('w', S4, R6->exits);
	R7->setExit('n', S8, R7->exits);
	R7->setExit('e', S5, R7->exits);
	R7->setExit('s', S2, R7->exits);
	R7->setExit('w', R6, R7->exits);
	S1->setExit('e', R2, S1->exits);
	S2->setExit('n', R7, S2->exits);
	S3->setExit('e', R5, S3->exits);
	S4->setExit('e', R6, S4->exits);
	S4->setExit('w', R5, S4->exits);
	S5->setExit('w', R7, S5->exits);
	S6->setExit('s', R5, S6->exits);
	S7->setExit('s', R6, S7->exits);
	S8->setExit('s', R7, S8->exits);

	//all items (13 in total)
	S1->addItem(new item("FLOUR"), S1->items);
	S1->addItem(new item("SUGAR"), S1->items);
	S1->addItem(new item("SALT"), S1->items);
	S2->addItem(new item("CHOCOLATE"), S2->items);
	S2->addItem(new item("PEANUTS"), S2->items);
	S3->addItem(new item("EGGS"), S3->items);
	S4->addItem(new item("APPLES"), S4->items);
	S1->addItem(new item("PEACHES"), S4->items);
	S6->addItem(new item("MILK"), S6->items);
	S6->addItem(new item("BUTTER"), S6->items);
	S7->addItem(new item("SPICE"), S7->items);
	S8->addItem(new item("CARROT"), S8->items);
	S8->addItem(new item("ZUCCHINI"), S8->items);

	//all recipes (5 in total, listed easiest to hardest). recipes were generated by ChatGPT
	vector<const char*> appleStrudel = {"FLOUR", "SUGAR", "SALT", "BUTTER", "APPLES", "SPICE"};
	vector<const char*> peachCobbler = {"FLOUR", "SUGAR", "SALT", "MILK", "BUTTER", "PEACHES", "SPICE"};
	vector<const char*> zucchiniBread = {"FLOUR", "SUGAR", "SALT", "EGGS", "BUTTER", "ZUCCHINI", "SPICE"};
	vector<const char*> carrotCake = {"FLOUR", "SUGAR", "SALT", "EGGS", "BUTTER", "CARROT", "SPICE"};
	vector<const char*> spicedChocCookies = {"FLOUR", "SUGAR", "SALT", "EGGS", "BUTTER", "SPICE", "CHOCOLATE", "PEANUTS"};

	//player variables
	room* currentRoom = HOME;
	vector<item*> inv;
	int recipeNum = 0;
	int moves = 0;
	char playerName[40];
	bool stillPlaying = true;
	char currentRecipe[30];
	vector<const char*> recipe;

	//randomize which recipe is used
	srand(time(NULL));
	recipeNum = rand() % 5 + 1;
	if (recipeNum == 1) {
		strcpy(currentRecipe, "Apple Strudel");
		recipe = appleStrudel;
	} else if (recipeNum == 2) {
		strcpy(currentRecipe, "Peach Cobbler");
		recipe = peachCobbler;
	} else if (recipeNum == 3) {
		strcpy(currentRecipe, "Zucchini Bread");
		recipe = zucchiniBread;
	} else if (recipeNum == 4) {
		strcpy(currentRecipe, "Carrot Cake");
		recipe = carrotCake;
	} else if (recipeNum == 5) {
		strcpy(currentRecipe, "Spiced Chocolate Chip Cookies");
		recipe = spicedChocCookies;
	}

	cout << "Please enter your name:" << endl << "> ";
	cin.get(playerName, 41);
	cin.get();
	INFO(playerName, currentRecipe);
	while (stillPlaying) {
		char input[20];
		cin.get(input, 21);
		cin.get();
		if (strcmp(input, "RECIPE") == 0) {
			//look at needed ingredients
			RECIPE(recipe, inv, S5, currentRecipe);
		} else if (strcmp(input, "GO") == 0) {
			//list options, ask for direction
			GO(currentRoom, moves);
		} else if (strcmp(input, "GET") == 0) {
			//if there are items in the room, ask which one then grab it!
			GET(currentRoom, inv);
		} else if (strcmp(input, "SEARCH") == 0) {
			//current room, nearby rooms
			cout << "You are in " << currentRoom->getName() << " at " << currentRoom->getStreet() << ". The nearby destinations are:" << endl;
			currentRoom->seeExits(currentRoom->exits);
			cout << "> ";
		} else if (strcmp(input, "DROP") == 0) {
			//remove item from inventory, add to room item vect
			DROP(currentRoom, inv);
		} else if (strcmp(input, "INFO") == 0) {
			//tutorial screen again
			INFO(playerName, currentRecipe);
		} else {
			cout << "Invalid command. Check capitalization and spelling" << endl << "> ";
		}
		if (BAKE(S5, recipe, currentRecipe)) stillPlaying = false;
	}
	//win text
	cout << "All ingredients collected to make \e[33m" << currentRecipe << "\e[0m! Let the baking commence!" << endl;
	cout << "It took you \e[33m" << moves << "\e[0m steps to gather all ingredients. Play again!";
}

void GO(room* &currentRoom, int &moves) {
	cout << "Where would you like to go? Enter the letter preceding the destination" << endl;
	currentRoom->seeExits(currentRoom->exits); //allow user to see all directions and exits
	cout << "> ";
	char dir;
	cin >> dir;
	cin.ignore();
	int count = currentRoom->exits.size();
	map<char, room*>::iterator iter;
	for (iter = currentRoom->exits.begin(); iter != currentRoom->exits.end(); ++iter) {
		if (dir == iter->first) {
			currentRoom = iter->second; //change current room to new room
			moves++;
			cout << "You are now in \e[33m" << iter->second->getName() << "\e[0m, at \e[32m" << iter->second->getStreet() << "\e[0m" << endl;
			if (currentRoom->items.size() != 0) {
				cout << "The items here are:" << endl; //list items
				currentRoom->seeItems(currentRoom->items);
			}
			cout << "> ";
			return;
		} else count--;
	}
	//if direction is not valid, print
	if (count == 0) cout << "Not a valid direction. Check your spelling and if the direction has a destination associated with it" << endl << "> ";
	return;
}

void GET(room* &currentRoom, vector<item*> &inv) {
	if (currentRoom->items.size() == 0) { //room must have items
		cout << "No items at this destination to grab" << endl << "> ";
		return;
	} else {
		cout << "What would you like to get?" << endl << "> ";
		char roomItem[20];
		cin.get(roomItem, 21);
		cin.get();
		vector<item*>::iterator i;
		for (i = currentRoom->items.begin(); i < currentRoom->items.end(); i++) {
			if (strcmp((*i)->getName(), roomItem) == 0) { //see if typed item matches to existing item
				inv.push_back(currentRoom->getItem(roomItem, currentRoom->items));
				cout << "> ";
				return;
			}
		}
	}
}

void DROP(room* &currentRoom, vector<item*> &inv) {
	if (inv.size() == 0) { //must have items in inventory
		cout << "No items in inventory" << endl << "> ";
		return;
	} else {
		cout << "What would you like to drop? Type ALL to drop all items" << endl << "> ";
		char dropItem[20];
		cin.get(dropItem, 21);
		cin.get();
		if (strcmp(dropItem, "ALL") == 0) {
		    vector<item*>::iterator i;
		    for (i = inv.begin(); i < inv.end(); i++) {
		        currentRoom->addItem((*i), currentRoom->items); //add item to room
		    	cout << "\e[34m" << (*i)->getName() << "\e[0m has been dropped" << endl;
		    }
		    inv.clear();
		    cout << "> ";
			return;
		} else {
		    vector<item*>::iterator i;
		    for (i = inv.begin(); i < inv.end(); i++) {
			    if (strcmp((*i)->getName(), dropItem) == 0) {
				    currentRoom->addItem((*i), currentRoom->items); //add item to room
		    		cout << "\e[34m" << (*i)->getName() << "\e[0m has been dropped" << endl;
			    	inv.erase(i);
				    cout << "> ";
				    return;
			    }
		    }
		}
		
	}
}

bool BAKE(room* myStore, vector<const char*> recipe, char* recipeName) { //see if all ingredients are dropped
	int ingredientNum = recipe.size();
	vector<const char*>::iterator iter;
	for (iter = recipe.begin(); iter < recipe.end(); iter++) {
		vector<item*>::iterator i;
		for (i = myStore->items.begin(); i < myStore->items.end(); i++) {
			if (strcmp((*iter), (*i)->getName()) == 0) {
				ingredientNum--;
			}
		}
	}
	if (ingredientNum == 0) {
		return true;
	}
	return false;
}

void RECIPE(vector<const char*> vect, vector<item*> inv, room* myStore, char* recipe) {
	cout << "Recipe: \e[33m" << recipe << "\e[0m" << endl;
	vector<const char*>::iterator iter;
	for (iter = vect.begin(); iter < vect.end(); iter++) {
		cout << "- " << (*iter);
		vector<item*>::iterator it;
		for (it = myStore->items.begin(); it < myStore->items.end(); it++) {
			if (strcmp((*iter), (*it)->getName()) == 0) cout << " \e[31m(delivered)\e[0m"; //say delivered if at store
		}
		vector<item*>::iterator i;
		for (i = inv.begin(); i < inv.end(); i++) {
			if (strcmp((*iter), (*i)->getName()) == 0) cout << " \e[33m(obtained)\e[0m"; //say obtained if in inventory
		}
		cout << endl;
	}
	cout << "> ";
}

void INFO(char* name, char* recipe) {
	cout << "Welcome, Baker " << name << "! It is currently 3:00 AM, and you must gather ingredients to bake goods for your store! Today's recipe is: \e[33m" << recipe << "\e[0m!" << endl << "You can see what ingredients you will need by typing \e[31mRECIPE\e[0m. Get started with moving using the command \e[31mGO\e[0m, and pick up items using \e[31mGET\e[0m. Once you drop all ingredients in your store using \e[31mDROP\e[0m, your objective will be finished! See nearby areas using the commmand \e[31mSEARCH\e[0m, and access this page again using \e[31mINFO\e[0m!" << endl << "> ";
}
